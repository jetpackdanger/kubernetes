#!/usr/local/sbin/charm-env python3
#
# For a usage examples, see README.md
#
# TODO
#
# - make the action idempotent (i.e. if you run it multiple times, the first
# run will create/delete the registry, and the reset will be a no-op and won't
# error out)
#
# - take only a plain authentication file, and create the encrypted version in
# the action
#
# - when https://bugs.launchpad.net/juju/+bug/1661015 is fixed, handle the
# base64 encoding the parameters in the action itself
#
# - support multiple registries

import os
import sys

from base64 import b64encode

from charmhelpers.core.hookenv import action_get
from charmhelpers.core.hookenv import action_set
from charms.templating.jinja2 import render
from subprocess import call, check_output

os.environ['PATH'] += os.pathsep + os.path.join(os.sep, 'snap', 'bin')

deletion = action_get('delete')

context = {}

arch = check_output(['dpkg', '--print-architecture']).rstrip()
context['arch'] = arch.decode('utf-8')

# These config options must be defined in the case of a creation
param_error = False
for param in ('domain', 'htpasswd-plain'):
    value = action_get(param)
    if not value and not deletion:
        key = "external-registry-create-parameter-{}".format(param)
        error = "failure, parameter {} is required".format(param)
        action_set({key: error})
        param_error = True

    context[param] = value

# Create the dockercfg template variable
dockercfg = '{"%s": {"auth": "%s", "email": "root@localhost"}}' % \
            (context['domain'], context['htpasswd-plain'])
context['dockercfg'] = b64encode(dockercfg.encode()).decode('ASCII')

if param_error:
    sys.exit(0)

# Declare a kubectl template when invoking kubectl
kubectl = ['kubectl', '--kubeconfig=/root/.kube/config']

# Remove deployment if requested
if deletion:
    resources = ['secrets/registry-auth-data', 'secrets/registry-access']

    delete_command = kubectl + ['delete', '--ignore-not-found=true'] + resources
    delete_response = call(delete_command)
    if delete_response == 0:
        action_set({'external-registry-delete': 'success'})
    else:
        action_set({'external-registry-delete': 'failure'})

    sys.exit(0)

# Creation request
render('external-registry.yaml', '/root/cdk/addons/external-registry.yaml',
       context)

create_command = kubectl + ['create', '-f',
                            '/root/cdk/addons/external-registry.yaml']

create_response = call(create_command)

if create_response == 0:
    action_set({'external-registry-create': 'success'})

    # Patch the "default" serviceaccount with an imagePullSecret.
    # This will allow the docker daemons to authenticate to the
    # external registry automatically
    patch = '{"imagePullSecrets":[{"name":"registry-access"}]}'
    patch_sa_command = kubectl + ['patch', 'sa', 'default', '-p', patch]
    patch_sa_response = call(patch_sa_command)

    if patch_sa_response == 0:
        action_set({'serviceaccount-patch': 'success'})
    else:
        action_set({'serviceaccount-patch': 'failure'})


else:
    action_set({'external-registry-create': 'failure'})
